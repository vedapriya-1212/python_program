# -*- coding: utf-8 -*-
"""numpy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mnuIJVaI4Sh6odeCtCpkLJKgX6PspnRj
"""

import numpy as np
arr_1d=np.array([1,2,3])
print(arr_1d)
print('\n')
arr_2d=np.array([[1,2,3],[4,5,6]])
print(arr_2d)
print('\n')
arr_3d=np.array([[[1,2,3],[4,5,6]],[[7,8,9],[1,2,3]]])
print(arr_3d)
print('\n')
print(arr_2d.ndim)
print(arr_3d.ndim)

zero=np.zeros((2,3))
print(zero)
print('\n')
one=np.ones((3,3))
print(one)
print('\n')
random_arr=np.random.random((2,2))
print(random_arr)
print('\n')
identity=np.eye(3)
print(identity)
print('\n')
arange_arr=np.arange(0,10,2)
print(arange_arr)

arr=np.array([[1,2,3],[4,5,6]])
print("Shape:",arr.shape)
print("Size:",arr.size)
print("Data type:",arr.dtype)
print("Number of dimensions:",arr.ndim)

"""You are working as a Data Engineer for a smart agriculture startup that collects sensor data from multiple greenhouses.
Each greenhouse has sensors that record temperature (°C) readings at different times of the day.
You received the following data:
Your tasks are:
Create NumPy arrays
Create a 2D NumPy array named temp_data to represent the temperature readings from both greenhouses.
Print the array.
Check array properties
Print the shape, size, data type, and number of dimensions of temp_data.
Add a third greenhouse
The third greenhouse (GH3) records [21, 23, 22].
Create a new array updated_temp_data that includes all three greenhouses.
Generate supporting data
Create a zeros array (2×3) called sensor_error_flags to represent whether there were any sensor errors (0 means no error).
Create an identity matrix of size 3×3 named greenhouse_identity to uniquely identify each greenhouse.
Display all arrays
Print updated_temp_data, sensor_error_flags, and greenhouse_identity.
"""

gh1=np.array([22,25,20])
gh2=np.array([24,26,23])
temp_data=np.array([gh1,gh2])
print(temp_data)
print("shape:",temp_data.shape)
print("size:",temp_data.size)
print("datatype:",temp_data.dtype)
print("Number of dimensions:",temp_data.ndim)
gh3=([21,23,22])
updated_temp_data=np.array([gh1,gh2,gh3])
sensor_error_flags=np.zeros((2,3))
greenhouse_identity=np.eye(3)
print("\n")
print(updated_temp_data)
print("\n")
print(sensor_error_flags)
print("\n")
print(greenhouse_identity)

arr=np.array([[10,20,30],[40,50,60]])
print(arr[0,1])
print(arr[1,-1])
print(arr[:,1:])

"""Indexing and Slicing:
You are working as a Data Analyst at a fruit distribution company.
The company stores the number of fruit boxes shipped per day (for 1 week) in a 2D NumPy array where:
Each row represents a type of fruit.
Each column represents a day of the week (Mon–Sun).


Your Tasks
Create the 2D NumPy array
Create an array named shipments using the above data.
Access single elements (Indexing):
Get the number of Apples shipped on Wednesday.
Get the number of Oranges shipped on Sunday.
Access multiple elements (Slicing):
Extract all the weekday shipments (Mon–Fri) for all fruits.
Extract only the weekend shipments (Sat & Sun).
Extract the shipments of Apples from Wednesday to Saturday.
Bonus (Practice thinking):
Replace the Saturday shipment of Apples (currently 80) with 100 using indexing.
"""

apples=np.array([50,60,55,70,65,80,90])
oranges=np.array([40,45,50,60,55,70,75])
shipments=np.array([apples,oranges])
print(shipments[0,2])
print(shipments[1,-1])
print('\n')
print(shipments[:,:5])
print('\n')
print(shipments[:,-2:])
print('\n')
print(shipments[0,2:-1])
shipments[0,-2]=100
print('\n')
print(shipments[0,-2])

a=np.array([1,2,3])
b=np.array([4,5,6])
print(a+b)
print(a-b)
print(a*b)
print(a*2)
mat1=np.array([[1,2],[3,4]])
mat2=np.array([[5,6],[7,8]])
mat=np.dot(mat1,mat2)
print(mat)

#broadcasting
a=np.array([1,2,3])
b=2
print(a+b)

#universal function
arr=np.array([1,2,3])
arr1=np.array([4,5,6])
print(np.exp(arr))
print(np.sqrt(arr))
print(np.log(arr))
print(np.add(arr,arr1))
print(np.subtract(arr,arr1))
print(np.power(arr,arr1))
print(np.divide(arr,arr1))
print(np.expm1(arr))
print(np.sin(arr))
print(np.degrees(arr))
print(np.radians(arr))
arr2=np.array([2.3,4.4,2.91])
print(np.trunc(arr2))
print(np.ceil(arr2))
print(np.min(arr))
print(np.mean(arr))
print(np.std(arr))
print(np.var(arr))
print(np.sum(arr))
print(np.prod(arr))
print(np.logical_and(arr,arr1))
print(np.logical_not(arr,arr1))
print(np.logical_xor(arr,arr1))
print(np.greater(arr,arr1))
print(np.equal(arr,arr1))
print(np.less_equal(arr,arr1))
print(np.bitwise_and(arr,arr1))
print(np.invert(arr,arr1))

"""You are a data engineer at a renewable-energy company that runs 3 solar farms.
Each farm has 4 solar panels, and each panel reports hourly energy production (kWh) for 3 hours during a test window.

Given data (raw)
Create arrays from these values:
production — shape (3 farms × 4 panels × 3 hours) represented as a 2D array per farm (you can stack/create as shown in tasks).
Farm A panels (rows = panels, cols = hours):


Tasks
Create arrays
Create three 2D NumPy arrays farmA, farmB, farmC (each shape (4,3)).
Stack them into a single 3D array production_all of shape (3, 4, 3).
Array attributes
Print the .shape, .size, .dtype, and .ndim of production_all.
Per-farm totals (arithmetic & aggregation)
Use aggregation ufuncs to compute the total energy per farm (sum across panels & hours) → total_per_farm (shape (3,)).
Compute mean, std, and var per farm.
Per-hour matrix multiplication idea (matrix op)
For a quick weighted estimate, create a hour_weights row vector of shape (3,) = [0.5, 1.0, 0.75] (weights for hour1, hour2, hour3).
Compute weighted_per_panel by performing a dot product between each farm's panel-row and hour_weights to get per-panel weighted energy. (Use np.dot / matrix multiplication appropriately.)
Broadcasting adjustments
The operator notices a fixed calibration offset of +0.5 kWh for all panels in Farm B. Use broadcasting to add this offset to Farm B data inside production_all (without recreating whole array manually).
Element-wise arithmetic (ufuncs: add/sub/mul/div/power/mod)
Compute a normalized version where you:
subtract the per-farm mean (use broadcasting),
divide by the per-farm std (broadcasting) — i.e., z-score normalize each farm's panel-hour readings.
Apply many ufuncs (use the ufuncs listed previously)
Apply the following element-wise operations (create variables for each) on the normalized data (or a copy) and show the resulting arrays (or summaries — shape/dtype/first row) where appropriate:
Exponential family: np.exp, np.expm1, np.log (note: handle non-positive inputs if needed), np.log10, np.log2.
Trigonometric: np.sin, np.cos, np.tan, np.arcsin, np.arccos, np.arctan, plus np.degrees, np.radians applied appropriately.
Rounding: np.round, np.floor, np.ceil, np.trunc.
Comparison & logical ufuncs: create a boolean mask high_output = production_all > 20 and apply np.logical_and, np.logical_or, np.logical_not, np.logical_xor combining masks (e.g., high_output and even_hours_mask). Also use comparison ufuncs like np.greater_equal, np.less.
Bitwise ufuncs (on integer arrays): create an integer array alerts = np.array([[1,0,1],[0,0,1],[1,1,0],[0,1,0]]) for each farm (shape match required) — then apply np.bitwise_and, np.bitwise_or, np.invert where sensible.
Arithmetic ufuncs again: np.add, np.subtract, np.multiply, np.divide, np.power, np.mod.
Aggregations over ufunc outputs: e.g., np.sum(np.exp(...)), np.mean(np.sin(...)).
Broadcast-based summary table
Use broadcasting to compute a (3,4) array panel_totals_per_farm = total per panel (sum across hours for each panel), and then compute a (3,) boolean needs_maintenance saying True if any panel in that farm has total < 40. Use np.min, np.max, np.any, np.all.
Final KPIs (aggregation)
Compute:
overall_total (sum of all farms),
peak_hour value (max across hours) and which farm & panel produced it (use np.argmax with careful unraveling),
average_per_panel across all farms.
"""

fa=np.array([[10,12,11],[9,11,10],[12,13,14],[8,7,9]])
fb=np.array([[20,19,21],[18,20,19],[22,23,21],[17,18,16]])
fc=np.array([[15,16,14],[14,13,15],[16,17,18],[12,11,13]])
production_all=np.array([fa,fb,fc])
print(production_all.shape)
print(production_all.size)
print(production_all.dtype)
print(production_all.ndim)


total_per_farm = production_all.sum(axis=(1, 2))
print("\nTotal energy per farm:", total_per_farm)

mean_per_farm = production_all.mean(axis=(1, 2))
print("Mean energy per farm:", mean_per_farm)

std_per_farm = production_all.std(axis=(1, 2))
print("Standard deviation per farm:", std_per_farm)

var_per_farm = production_all.var(axis=(1, 2))
print("Variance per farm:", var_per_farm)


hour_weights=np.array([0.5,1.0,0.75])
weighted_per_panel=np.dot(production_all,hour_weights)
print("\nWeighted energy per panel:\n", weighted_per_panel)



production_all[1] = production_all[1] + 0.5
print("\nProduction data after adding offset to Farm B:")
print(production_all)


mean_per_farm_reshaped = mean_per_farm[:, np.newaxis, np.newaxis]
std_per_farm_reshaped = std_per_farm[:, np.newaxis, np.newaxis]


normalized_production = np.divide(production_all - mean_per_farm_reshaped, std_per_farm_reshaped, out=np.zeros_like(production_all, dtype=float), where=(std_per_farm_reshaped != 0))
print("\nNormalized production data (z-score per farm):\n", normalized_production)


print("\nApplying ufuncs:")
print("exp:\n", np.exp(production_all))
print("expm1:\n", np.expm1(production_all))

print("log:\n", np.log(production_all, out=np.zeros_like(production_all, dtype=float), where=(production_all > 0)))
print("log10:\n", np.log10(production_all, out=np.zeros_like(production_all, dtype=float), where=(production_all > 0)))
print("log2:\n", np.log2(production_all, out=np.zeros_like(production_all, dtype=float), where=(production_all > 0)))

print("sin:\n", np.sin(production_all))
print("cos:\n", np.cos(production_all))
print("tan:\n", np.tan(production_all))

print("degrees:\n", np.degrees(production_all))
print("radians:\n", np.radians(production_all))

print("round:\n", np.round(production_all))
print("floor:\n", np.floor(production_all))
print("ceil:\n", np.ceil(production_all))
print("trunc:\n", np.trunc(production_all))

high_output = production_all > 20
even_hours_mask = np.zeros_like(production_all, dtype=bool)
even_hours_mask[:, :, [0, 2]] = True # Assuming hours 0 and 2 are 'even' in a 0-indexed sense
print("logical_and (high_output and even_hours_mask):\n", np.logical_and(high_output, even_hours_mask))
print("logical_or (high_output or even_hours_mask):\n", np.logical_or(high_output, even_hours_mask))
print("logical_not (high_output):\n", np.logical_not(high_output))
print("logical_xor (high_output and even_hours_mask):\n", np.logical_xor(high_output, even_hours_mask))
print("greater_equal (production_all >= 20):\n", np.greater_equal(production_all, 20))
print("less (production_all < 20):\n", np.less(production_all, 20))


alerts = np.array([[[1,0,1],[0,0,1],[1,1,0],[0,1,0]],
                   [[1,0,1],[0,0,1],[1,1,0],[0,1,0]],
                   [[1,0,1],[0,0,1],[1,1,0],[0,1,0]]])


production_all_int = production_all.astype(int)

print("bitwise_and (alerts and production_all_int):\n", np.bitwise_and(alerts, production_all_int))

print("invert (alerts):\n", np.invert(alerts))
print("bitwise_or (alerts or production_all_int):\n", np.bitwise_or(alerts, production_all_int))

print("add (alerts and production_all_int):\n", np.add(alerts, production_all_int))
print("subtract (alerts and production_all_int):\n", np.subtract(alerts, production_all_int))
print("multiply (alerts and production_all_int):\n", np.multiply(alerts, production_all_int))

print("divide (alerts by production_all_int):\n", np.divide(alerts, production_all_int, out=np.zeros_like(alerts, dtype=float), where=(production_all_int != 0)))

print("power (alerts to production_all_int):\n", np.power(alerts, production_all_int, out=np.zeros_like(alerts, dtype=float), where=(production_all_int >= 0)))

print("mod (alerts by production_all_int):\n", np.mod(alerts, production_all_int, out=np.zeros_like(alerts, dtype=float), where=(production_all_int != 0)))


print("sum(exp(production_all)):\n", np.sum(np.exp(production_all)))
print("mean(sin(production_all)):\n", np.mean(np.sin(production_all)))


panel_totals_per_farm = production_all.sum(axis=2)
print("\nPanel totals per farm:\n", panel_totals_per_farm)

needs_maintenance = (panel_totals_per_farm < 40).any(axis=1)
print("Farms needing maintenance:\n", needs_maintenance)

overall_total = production_all.sum()
print("\nOverall total energy production:", overall_total)

peak_hour_value = production_all.max()
print("Peak hour energy value:", peak_hour_value)

peak_location_flat = production_all.argmax()
peak_location_multi_dim = np.unravel_index(peak_location_flat, production_all.shape)
print("Location of peak hour value (farm, panel, hour):", peak_location_multi_dim)

average_per_panel_all_farms = production_all.mean(axis=(0, 2))
print("Average energy per panel across all farms:", average_per_panel_all_farms)

arr=np.array([1,2,3,4,5,6])
reshaped=arr.reshape(2,3)
print(reshaped)

a=np.array([1,2])
b=np.array([3,4])
print(np.vstack((a,b)))
print(np.hstack((a,b)))
arr3=np.array([1,2,3,4,5,6])
print(np.array_split(arr,4))

#advanced indenxing
#boolean indexing
arr=np.array([1,2,3,4,5])
print(arr[arr>3])
#fancy indexing
arr=np.array([10,20,30,40])
indices=[0,2]
print(arr[indices])

#copy vs view
arr=np.array([1,2,3])
view=arr.view()#view shares memory
view[0]=10
print(arr)
copy=arr.copy()#copy doesnt share memory
copy[0]=10
print(arr)

#saving an dloading
arr=np.array([1,2,3])
np.save('array.npy',arr)
loaded_arr=np.load('array.npy')
print(loaded_arr)

"""TasksArray Creation
Create a 1D array of numbers from 10 to 50.
Create a 3x3 array of random numbers between 0 and 1.
Array Attributes
Find the shape, size, and data type of the array you created in the previous task.
Basic Operations
Add 5 to every element of a 1D array.
Multiply two 2D arrays element-wise.
Indexing and Slicing
Create a 5x5 array of integers from 1 to 25. Extract:
The first row.
The last column.
A subarray of the first three rows and first two columns.
Aggregation
Create a 10-element array of random integers between 10 and 100. Find:
The maximum value.
The minimum value.
The mean and standard deviation.
Reshaping
Convert a 1D array of numbers from 1 to 12 into a 3x4 matrix.
Broadcasting
Create a 3x3 matrix of ones. Add a 1D array [1, 2, 3] to each row.
Filtering
Create a 1D array of random integers between 1 and 50. Extract all elements that are divisible by 5.
Matrix Multiplication
Create two 2x2 matrices and perform matrix multiplication.
Advanced Indexing
Given a 4x4 array, use fancy indexing to extract the diagonal elements.
"""

import numpy as np

arr1d = np.arange(10, 51)
print(arr1d)
arr33=np.random.random((3,3))
print(arr33)
print(arr1d.shape)
print(arr1d.size)
print(arr1d.dtype)
print(arr1d+5)
arr1=np.array([[1,2],[3,4]])
arr2=np.array([[5,6],[7,8]])
print(arr1*arr2)
arr5=np.arange(1,26)
arr55=arr5.reshape(5,5)
print(arr55)
print(arr55[0,])
print(arr55[:, -1])
print(arr55[:3,:2])
arr10=np.random.randint(10,100,size=(1,10))
print(arr10)
print(np.max(arr10))
print(np.min(arr10))
print(np.mean(arr10))
print(np.std(arr10))
a1=np.arange(1,13)
print(a1.reshape(3,4))
aone=np.ones((3,3))
a1d=np.array([1,2,3])
print(aone+a1d)
arand=np.random.randint(1,51,size=10)
print(arand[arand%5==0])
print(np.dot(arr1,arr2))
a44=np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])
indices=[0,1,2,3]
print(a44[indices,indices])